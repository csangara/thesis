paste0(celltype, "_cibersort")), combine=FALSE)
plots[[2]] <- plots[[2]] + ggtitle("SPOTlight", paste0("Corr=",
round(spotlight_corr_celltypes[celltype, celltype], 3)))
plots[[3]] <- plots[[3]] + ggtitle("MuSiC", paste0("Corr=",
round(music_corr_celltypes[celltype, celltype], 3)))
plots[[4]] <- plots[[4]] + ggtitle("CIBERSORT", paste0("Corr=",
round(cibersort_corr_celltypes[celltype, celltype], 3)))
plots <- plots[[1]] + plots[[2]] + plots[[3]]+plots[[4]]
png(paste0(plot_dir, str_replace(celltype, "/", "."), ".png"), width=1000, height=500)
print(plots)
dev.off()
}
library(patchwork)
library(ggplot2)
for (celltype in celltypes){
# Add deconv result to visium metadata
seurat_obj_visium@meta.data[celltype] = synthetic_visium_data$relative_spot_composition[,celltype]
seurat_obj_visium@meta.data[paste0(celltype, "_spotlight")] = spotlight_deconv[[2]][,celltype]
seurat_obj_visium@meta.data[paste0(celltype, "_music")] = music_deconv$Est.prop.weighted[,celltype]
seurat_obj_visium@meta.data[paste0(celltype, "_cibersort")] = cibersort_deconv[,celltype]
plot_dir <- paste0(path, "plots/allen_cortex_dwn/", dataset_type, "/")
if (!dir.exists(plot_dir)){ dir.create(plot_dir) }
plots <- FeaturePlot(seurat_obj_visium, c(celltype, paste0(celltype, "_spotlight"), paste0(celltype, "_music"),
paste0(celltype, "_cibersort")), combine=FALSE)
plots[[2]] <- plots[[2]] + ggtitle("SPOTlight", paste0("Corr=",
round(spotlight_corr_celltypes[celltype, celltype], 3)))
plots[[3]] <- plots[[3]] + ggtitle("MuSiC", paste0("Corr=",
round(music_corr_celltypes[celltype, celltype], 3)))
plots[[4]] <- plots[[4]] + ggtitle("CIBERSORT", paste0("Corr=",
round(cibersort_corr_celltypes[celltype, celltype], 3)))
plots <- plots[[1]] + plots[[2]] + plots[[3]]+plots[[4]]
png(paste0(plot_dir, str_replace(celltype, "/", "."), ".png"), width=1000, height=500)
print(plots)
dev.off()
}
length(known_props[,1:23])
sqrt(sum((known_props[,1:23]-test[,1:23])**2)/length(known_props[,1:23]))
sqrt(sum((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2)/length(known_props[,1:23]))
sum((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2)
(known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2
sum((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2)
sum((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2)
all(!is.na((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2))
all(is.na((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2))
dim(known_props[,1:23])
dim(spotlight_deconv[[2]][,1:23])
temp <- (known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2
is.na(temp)
known_props[is.na(temp)]
known_props[is.na(temp),]
which(is.na(temp))
is.na(known_props)
all(!is.na(known_props))
View(known_props)
synthetic_visium_data[1219m]
synthetic_visium_data[1219,]
synthetic_visium_data$spot_composition[1219,]
?sum
sqrt(sum((known_props[,1:23]-spotlight_deconv[[2]][,1:23])**2, na.rm=TRUE)/length(known_props[,1:23]))
music_RMSE <- sqrt(sum((known_props[,1:23]-music_deconv$Est.prop.weighted[,1:23])**2, na.rm=TRUE)/length(known_props[,1:23]))
music_RMSE
cor(known_props[,1:23], music_deconv$Est.prop.weighted[,1:23], use="complete.obs")
cibersort_RMSE <- sqrt(sum((known_props[,1:23]-cibersort_deconv[,1:23])**2, na.rm=TRUE)/length(known_props[,1:23]))
#### Calculate TP-TN-FP-FN ####
test_props <- cibersort_deconv[,1:23]
tp <- 0; tn <- 0; fp <- 0; fn <- 0
for (i in 1:nrow(known_props)){
for (j in 1:23){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
recall <- round(tp / (tp + fn), 2)
F1 <- round(2 * ((precision * recall) / (precision + recall)), 2)
cat(sprintf("The following summary statistics are obtained:
Accuracy: %s,
Sensitivity: %s,
Specificity: %s,
precision: %s,
recall: %s,
F1 score: %s",
accuracy, sensitivity, specificity, precision, recall, F1, sep = "\n"))
test_props <- cibersort_deconv[,1:23]
tp <- 0; tn <- 0; fp <- 0; fn <- 0
for (i in 1:nrow(known_props)){
for (j in 1:23){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
cat(sprintf("The following summary statistics are obtained:
Accuracy: %s,
Sensitivity: %s,
Specificity: %s,
Precision: %s,
F1 score: %s",
accuracy, sensitivity, specificity, precision, F1, sep = "\n"))
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
getConfusionMatrix(known_props, test_props)
ncol(known_props)
test_props <- cibersort_deconv[,1:23]
tp <- 0; tn <- 0; fp <- 0; fn <- 0
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
dataset_type
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
missing_vals <- is.na(known_props)
known_props <- known_props[-missing_vals]
test_props <- test_props[-missing_vals]
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
conf <- getConfusionMatrix(known_props, test_props)
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
test_props <- test_props[!is.na(known_props)]
known_props <- known_props[!is.na(known_props)]
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
conf <- getConfusionMatrix(known_props, test_props)
test_props <- test_props[!is.na(known_props)]
lapply(known_props, is.na, 1)
apply(known_props, is.na, 1)
apply(known_props, 1, is.na)
missing_rows <- apply(known_props, 1, is.na)
View(missing_rows)
missing_rows <- is.na(known_props)
View(missing_rows)
rowSums(missing_rows) > 0
sum(rowSums(missing_rows) > 0)
which(rowSums(missing_rows) > 0)
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
missing_rows <- which(rowSums(is.na(known_props)) > 0)
test_props <- test_props[-missing_rows,]
known_props <- known_props[-missing_rows,]
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
test_props <- cibersort_deconv[,1:23]
conf <- getConfusionMatrix(known_props, test_props)
deconv_methods <- c("spotlight, music")
metrics <- data.frame(row.names=deconv_methods)
View(metrics)
metrics
metrics <- data.frame(row.names=c(1,2,3))
metrics
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
View(metrics)
length(known_props[,1:23]
)
deconv_methods <- c("spotlight, music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- ncol(synthetic_visium_data$relative_spot_composition)
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[dataset_type] <- metrics
}
possible_dataset_types = c("real", "real_top1","real_top1_uniform","real_top2_overlap","real_top2_overlap_uniform",
"real_missing_celltypes_visium", "artificial_uniform_distinct", "artificial_diverse_distinct",
"artificial_uniform_overlap", "artificial_diverse_overlap", "artificial_dominant_celltype_diverse",
"artificial_partially_dominant_celltype_diverse", "artificial_missing_celltypes_visium")
deconv_methods <- c("spotlight, music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- ncol(synthetic_visium_data$relative_spot_composition)
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[dataset_type] <- metrics
}
for (deconv_method in deconv_methods){ print(deconv_method) }
deconv_methods <- c("spotlight", "music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- ncol(synthetic_visium_data$relative_spot_composition)
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[dataset_type] <- metrics
}
deconv_matrix
n_celltypes
synthetic_visium_data$relative_spot_composition
deconv_methods <- c("spotlight", "music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- 23
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[dataset_type] <- metrics
}
dataset_type
View(all_results)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
known_props
tp <- 0; tn <- 0; fp <- 0; fn <- 0
missing_rows <- which(rowSums(is.na(known_props)) > 0)
test_props <- deconv_matrix
View(test_props)
test_props <- test_props[-missing_rows,]
is.null(missing_rows)
is.empty(missing_rows)
missing_rows
missing_rows > 0
bool(missing_rows > 0)
length(missing_rows)
# Get the confusion matrix given ground truth and deconvoluted result
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
missing_rows <- which(rowSums(is.na(known_props)) > 0)
if (length(missing_Rows) > 0){
test_props <- test_props[-missing_rows,]
known_props <- known_props[-missing_rows,]
}
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
# Get the confusion matrix given ground truth and deconvoluted result
getConfusionMatrix <- function(known_props, test_props){
tp <- 0; tn <- 0; fp <- 0; fn <- 0
missing_rows <- which(rowSums(is.na(known_props)) > 0)
if (length(missing_rows) > 0){
test_props <- test_props[-missing_rows,]
known_props <- known_props[-missing_rows,]
}
for (i in 1:nrow(known_props)){
for (j in 1:ncol(known_props)){
if (known_props[i, j] > 0 & test_props[i, j] > 0){
tp <- tp + 1
} else if (known_props[i, j] == 0 & test_props[i, j] == 0){
tn <- tn + 1
} else if (known_props[i, j] > 0 & test_props[i, j] == 0){
fn <- fn + 1
} else if (known_props[i, j] == 0 & test_props[i, j] > 0){
fp <- fp + 1
}
}
}
return(list(tp=tp, tn=tn, fn=fn, fp=fp))
}
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
deconv_methods <- c("spotlight", "music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- 23
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[dataset_type] <- metrics
}
warnings()
View(all_results)
all_results["real"]
metrics
all_results[[dataset_type]] <- metrics
deconv_methods <- c("spotlight", "music")
all_results <- list()
for (dataset_type in possible_dataset_types){
# Load reference data and deconvolution results
result_path <- paste0(path, "rds/synthvisium_spatial/allen_cortex_dwn_", dataset_type, "_")
synthetic_visium_data <- readRDS(paste0(result_path, "synthvisium.rds"))
known_props <- synthetic_visium_data$relative_spot_composition[,1:23]
n_celltypes <- 23
metrics <- data.frame(row.names=c("corr", "RMSE", "accuracy", "sensitivity", "specificity", "precision", "F1"))
for (deconv_method in deconv_methods){
deconv_matrix <- readRDS(paste0(result_path, deconv_method, ".rds"))
if (deconv_method == "spotlight"){
deconv_matrix <- deconv_matrix[[2]]
} else if (deconv_method == "music"){
deconv_matrix <- deconv_matrix$Est.prop.weighted
}
# Correlation and RMSE
corr_spots <- mean(diag(cor(t(known_props), t(deconv_matrix[,1:n_celltypes]))), na.rm=TRUE)
RMSE <- sqrt(sum((known_props-deconv_matrix[,1:n_celltypes])**2, na.rm=TRUE)/n_celltypes)
# Classification scores
conf <- getConfusionMatrix(known_props, deconv_matrix)
tp <- conf$tp; tn <- conf$tn; fp <- conf$fp; fn <- conf$fn
accuracy <- round((tp + tn) / (tp + tn + fp + fn), 2)
sensitivity <- round(tp / (tp + fn), 2)
specificity <- round(tn / (tn + fp), 2)
precision <- round(tp / (tp + fp), 2)
F1 <- round(2 * ((precision * sensitivity) / (precision + sensitivity)), 2)
# Get them into dataframe
metrics[deconv_method] <- c(corr_spots, RMSE, accuracy, sensitivity, specificity, precision, F1)
}
all_results[[dataset_type]] <- metrics
}
View(all_results)
